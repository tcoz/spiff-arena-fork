from celery.bin.base import Command
from typing import Any, Optional

def main(argv: Optional[Any] = ...) -> None: ...

class multi(Command):
    respects_app_option: bool = ...
    def run_from_argv(self, prog_name: Any, argv: Any, command: Optional[Any] = ...): ...

class help(Command):
    def usage(self, command: Any): ...
    def run(self, *args: Any, **kwargs: Any): ...

class report(Command):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def run(self, *args: Any, **kwargs: Any): ...

class CeleryCommand(Command):
    commands: Any = ...
    ext_fmt: str = ...
    enable_config_from_cmdline: bool = ...
    prog_name: str = ...
    namespace: str = ...
    @classmethod
    def register_command(cls, fun: Any, name: Optional[Any] = ...): ...
    def execute(self, command: Any, argv: Optional[Any] = ...): ...
    def on_usage_error(self, exc: Any, command: Optional[Any] = ...) -> None: ...
    def prepare_prog_name(self, name: Any): ...
    def handle_argv(self, prog_name: Any, argv: Any, **kwargs: Any): ...
    respects_app_option: bool = ...
    def execute_from_commandline(self, argv: Optional[Any] = ...) -> None: ...
    @classmethod
    def get_command_info(cls, command: Any, indent: int = ..., color: Optional[Any] = ..., colored: Optional[Any] = ..., app: Optional[Any] = ...): ...
    @classmethod
    def list_commands(cls, indent: int = ..., colored: Optional[Any] = ..., app: Optional[Any] = ...): ...
    def with_pool_option(self, argv: Any): ...
    def on_concurrency_setup(self) -> None: ...
    def load_extension_commands(self) -> None: ...
