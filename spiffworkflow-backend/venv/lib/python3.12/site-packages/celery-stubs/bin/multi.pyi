from typing import Any, Optional

class TermLogger:
    splash_text: str = ...
    splash_context: Any = ...
    retcode: int = ...
    stdout: Any = ...
    stderr: Any = ...
    nosplash: Any = ...
    quiet: Any = ...
    verbose: Any = ...
    no_color: Any = ...
    def setup_terminal(self, stdout: Any, stderr: Any, nosplash: bool = ..., quiet: bool = ..., verbose: bool = ..., no_color: bool = ..., **kwargs: Any) -> None: ...
    def ok(self, m: Any, newline: bool = ..., file: Optional[Any] = ...): ...
    def say(self, m: Any, newline: bool = ..., file: Optional[Any] = ...) -> None: ...
    def carp(self, m: Any, newline: bool = ..., file: Optional[Any] = ...): ...
    def error(self, msg: Optional[Any] = ...): ...
    def info(self, msg: Any, newline: bool = ...) -> None: ...
    def note(self, msg: Any, newline: bool = ...) -> None: ...
    def usage(self) -> None: ...
    def splash(self) -> None: ...
    def colored(self): ...

class MultiTool(TermLogger):
    MultiParser: Any = ...
    OptionParser: Any = ...
    reserved_options: Any = ...
    env: Any = ...
    cmd: Any = ...
    fh: Any = ...
    prog_name: str = ...
    commands: Any = ...
    def __init__(self, env: Optional[Any] = ..., cmd: Optional[Any] = ..., fh: Optional[Any] = ..., stdout: Optional[Any] = ..., stderr: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def execute_from_commandline(self, argv: Any, cmd: Optional[Any] = ...): ...
    def validate_arguments(self, argv: Any): ...
    def call_command(self, command: Any, argv: Any): ...
    def start(self, cluster: Any): ...
    def stop(self, cluster: Any, sig: Any, **kwargs: Any): ...
    def stopwait(self, cluster: Any, sig: Any, **kwargs: Any): ...
    stop_verify: Any = ...
    def restart(self, cluster: Any, sig: Any, **kwargs: Any): ...
    def names(self, cluster: Any) -> None: ...
    def get(self, wanted: Any, *argv: Any): ...
    def show(self, cluster: Any): ...
    def kill(self, cluster: Any): ...
    def expand(self, template: Any, *argv: Any): ...
    def help(self, *argv: Any) -> None: ...
    def cluster_from_argv(self, argv: Any, cmd: Optional[Any] = ...): ...
    def Cluster(self, nodes: Any, cmd: Optional[Any] = ...): ...
    def on_stopping_preamble(self, nodes: Any) -> None: ...
    def on_send_signal(self, node: Any, sig: Any) -> None: ...
    def on_still_waiting_for(self, nodes: Any) -> None: ...
    def on_still_waiting_progress(self, nodes: Any) -> None: ...
    def on_still_waiting_end(self) -> None: ...
    def on_node_signal_dead(self, node: Any) -> None: ...
    def on_node_start(self, node: Any) -> None: ...
    def on_node_restart(self, node: Any) -> None: ...
    def on_node_down(self, node: Any) -> None: ...
    def on_node_shutdown_ok(self, node: Any) -> None: ...
    def on_node_status(self, node: Any, retval: Any) -> None: ...
    def on_node_signal(self, node: Any, sig: Any) -> None: ...
    def on_child_spawn(self, node: Any, argstr: Any, env: Any) -> None: ...
    def on_child_signalled(self, node: Any, signum: Any) -> None: ...
    def on_child_failure(self, node: Any, retcode: Any) -> None: ...
    def OK(self): ...
    def FAILED(self): ...
    def DOWN(self): ...
