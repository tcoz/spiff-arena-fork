from billiard import pool as _pool
from collections import namedtuple
from typing import Any, Optional

Ack = namedtuple('Ack', ['id', 'fd', 'payload'])
FileNotFoundError = IOError

class Worker(_pool.Worker):
    def on_loop_start(self, pid: Any) -> None: ...

class ResultHandler(_pool.ResultHandler):
    fileno_to_outq: Any = ...
    on_process_alive: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def register_with_event_loop(self, hub: Any) -> None: ...
    def handle_event(self, *args: Any) -> None: ...
    def on_stop_not_started(self) -> None: ...

class AsynPool(_pool.Pool):
    ResultHandler: Any = ...
    Worker: Any = ...
    def WorkerProcess(self, worker: Any): ...
    sched_strategy: Any = ...
    synack: Any = ...
    outbound_buffer: Any = ...
    write_stats: Any = ...
    on_soft_timeout: Any = ...
    on_hard_timeout: Any = ...
    def __init__(self, processes: Optional[Any] = ..., synack: bool = ..., sched_strategy: Optional[Any] = ..., proc_alive_timeout: Optional[Any] = ..., *args: Any, **kwargs: Any) -> None: ...
    handle_result_event: Any = ...
    def register_with_event_loop(self, hub: Any) -> None: ...
    def on_job_ready(self, job: Any, i: Any, obj: Any, inqW_fd: Any) -> None: ...
    def flush(self) -> None: ...
    def get_process_queues(self): ...
    def on_grow(self, n: Any) -> None: ...
    def on_shrink(self, n: Any) -> None: ...
    def create_process_queues(self): ...
    def on_process_alive(self, pid: Any): ...
    def on_job_process_down(self, job: Any, pid_gone: Any) -> None: ...
    def on_job_process_lost(self, job: Any, pid: Any, exitcode: Any) -> None: ...
    def human_write_stats(self): ...
    def create_result_handler(self): ...
    def process_flush_queues(self, proc: Any) -> None: ...
    def on_partial_read(self, job: Any, proc: Any) -> None: ...
    def destroy_queues(self, queues: Any, proc: Any): ...
    @property
    def timers(self): ...
