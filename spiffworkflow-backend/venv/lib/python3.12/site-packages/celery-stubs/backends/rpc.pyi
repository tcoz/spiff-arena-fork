import kombu
from . import base
from .asynchronous import AsyncBackendMixin, BaseResultConsumer
from typing import Any, Optional

class BacklogLimitExceeded(Exception): ...

class ResultConsumer(BaseResultConsumer):
    Consumer: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def start(self, initial_task_id: Any, no_ack: bool = ..., **kwargs: Any) -> None: ...
    def drain_events(self, timeout: Optional[Any] = ...): ...
    def stop(self) -> None: ...
    def on_after_fork(self) -> None: ...
    def consume_from(self, task_id: Any): ...
    def cancel_for(self, task_id: Any) -> None: ...

class RPCBackend(base.Backend, AsyncBackendMixin):
    Exchange: Any = ...
    Producer: Any = ...
    ResultConsumer: Any = ...
    BacklogLimitExceeded: Any = ...
    persistent: bool = ...
    supports_autoexpire: bool = ...
    supports_native_join: bool = ...
    retry_policy: Any = ...
    class Consumer(kombu.Consumer):
        auto_declare: bool = ...
    class Queue(kombu.Queue):
        can_cache_declaration: bool = ...
    delivery_mode: Any = ...
    exchange: Any = ...
    serializer: Any = ...
    auto_delete: Any = ...
    result_consumer: Any = ...
    def __init__(self, app: Any, connection: Optional[Any] = ..., exchange: Optional[Any] = ..., exchange_type: Optional[Any] = ..., persistent: Optional[Any] = ..., serializer: Optional[Any] = ..., auto_delete: bool = ..., **kwargs: Any) -> None: ...
    def ensure_chords_allowed(self) -> None: ...
    def on_task_call(self, producer: Any, task_id: Any) -> None: ...
    def destination_for(self, task_id: Any, request: Any): ...
    def on_reply_declare(self, task_id: Any) -> None: ...
    def on_result_fulfilled(self, result: Any) -> None: ...
    def as_uri(self, include_password: bool = ...): ...
    def store_result(self, task_id: Any, result: Any, state: Any, traceback: Optional[Any] = ..., request: Optional[Any] = ..., **kwargs: Any): ...
    def on_out_of_band_result(self, task_id: Any, message: Any) -> None: ...
    def get_task_meta(self, task_id: Any, backlog_limit: int = ...): ...
    poll: Any = ...
    def revive(self, channel: Any) -> None: ...
    def reload_task_result(self, task_id: Any) -> None: ...
    def reload_group_result(self, task_id: Any) -> None: ...
    def save_group(self, group_id: Any, result: Any) -> None: ...
    def restore_group(self, group_id: Any, cache: bool = ...) -> None: ...
    def delete_group(self, group_id: Any) -> None: ...
    def __reduce__(self, args: Any = ..., kwargs: Optional[Any] = ...): ...
    @property
    def binding(self): ...
    def oid(self): ...
