from typing import Any, Optional

def flatten_reply(reply: Any): ...

class Inspect:
    app: Any = ...
    destination: Any = ...
    timeout: Any = ...
    callback: Any = ...
    connection: Any = ...
    limit: Any = ...
    pattern: Any = ...
    matcher: Any = ...
    def __init__(self, destination: Optional[Any] = ..., timeout: float = ..., callback: Optional[Any] = ..., connection: Optional[Any] = ..., app: Optional[Any] = ..., limit: Optional[Any] = ..., pattern: Optional[Any] = ..., matcher: Optional[Any] = ...) -> None: ...
    def report(self): ...
    def clock(self): ...
    def active(self, safe: Optional[Any] = ...): ...
    def scheduled(self, safe: Optional[Any] = ...): ...
    def reserved(self, safe: Optional[Any] = ...): ...
    def stats(self): ...
    def revoked(self): ...
    def registered(self, *taskinfoitems: Any): ...
    registered_tasks: Any = ...
    def ping(self, destination: Optional[Any] = ...): ...
    def active_queues(self): ...
    def query_task(self, *ids: Any): ...
    def conf(self, with_defaults: bool = ...): ...
    def hello(self, from_node: Any, revoked: Optional[Any] = ...): ...
    def memsample(self): ...
    def memdump(self, samples: int = ...): ...
    def objgraph(self, type: str = ..., n: int = ..., max_depth: int = ...): ...

class Control:
    Mailbox: Any = ...
    app: Any = ...
    mailbox: Any = ...
    def __init__(self, app: Optional[Any] = ...): ...
    def inspect(self): ...
    def purge(self, connection: Optional[Any] = ...): ...
    discard_all: Any = ...
    def election(self, id: Any, topic: Any, action: Optional[Any] = ..., connection: Optional[Any] = ...) -> None: ...
    def revoke(self, task_id: Any, destination: Optional[Any] = ..., terminate: bool = ..., signal: Any = ..., **kwargs: Any): ...
    def terminate(self, task_id: Any, destination: Optional[Any] = ..., signal: Any = ..., **kwargs: Any): ...
    def ping(self, destination: Optional[Any] = ..., timeout: float = ..., **kwargs: Any): ...
    def rate_limit(self, task_name: Any, rate_limit: Any, destination: Optional[Any] = ..., **kwargs: Any): ...
    def add_consumer(self, queue: Any, exchange: Optional[Any] = ..., exchange_type: str = ..., routing_key: Optional[Any] = ..., options: Optional[Any] = ..., destination: Optional[Any] = ..., **kwargs: Any): ...
    def cancel_consumer(self, queue: Any, destination: Optional[Any] = ..., **kwargs: Any): ...
    def time_limit(self, task_name: Any, soft: Optional[Any] = ..., hard: Optional[Any] = ..., destination: Optional[Any] = ..., **kwargs: Any): ...
    def enable_events(self, destination: Optional[Any] = ..., **kwargs: Any): ...
    def disable_events(self, destination: Optional[Any] = ..., **kwargs: Any): ...
    def pool_grow(self, n: int = ..., destination: Optional[Any] = ..., **kwargs: Any): ...
    def pool_shrink(self, n: int = ..., destination: Optional[Any] = ..., **kwargs: Any): ...
    def autoscale(self, max: Any, min: Any, destination: Optional[Any] = ..., **kwargs: Any): ...
    def shutdown(self, destination: Optional[Any] = ..., **kwargs: Any): ...
    def pool_restart(self, modules: Optional[Any] = ..., reload: bool = ..., reloader: Optional[Any] = ..., destination: Optional[Any] = ..., **kwargs: Any): ...
    def heartbeat(self, destination: Optional[Any] = ..., **kwargs: Any): ...
    def broadcast(self, command: Any, arguments: Optional[Any] = ..., destination: Optional[Any] = ..., connection: Optional[Any] = ..., reply: bool = ..., timeout: float = ..., limit: Optional[Any] = ..., callback: Optional[Any] = ..., channel: Optional[Any] = ..., pattern: Optional[Any] = ..., matcher: Optional[Any] = ..., **extra_kwargs: Any): ...
